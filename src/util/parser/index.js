import { parse_col_id_format } from '../helpers.js'

import nearley from 'nearley'

import raw_excel_grammar from './excel.js'
import raw_string_grammar from './string.js'

const excel_grammar = nearley.Grammar.fromCompiled(raw_excel_grammar)
const string_grammar = nearley.Grammar.fromCompiled(raw_string_grammar)

const _compile_binary_operator = (op, [fst, snd]) => `${compile_inner(fst)} ${op} ${compile_inner(snd)}`

const _compile_unary_operator = (op, fst) => `${op}${compile_inner(fst)}`

const compile = ast => {
  // I know this is not considered good code, but using eval is pretty much the only choice here,
  // the other choice would be to completely interpret the ast everytime which is also not good
  // for performance reasons, better to just transpile to javascript once and be done with it.
  // As the code is generated from an AST which is generated by a DSL the chance of somehow getting
  // malicious code running through this is *not that high*.
  const transpiled_code = `(g, lib) => ${compile_inner(ast[0])}`
  try {
    /* eslint-disable-next-line */
    return window.eval(transpiled_code)
  } catch(e) {
    console.error(transpiled_code, e)
  }
}

const compile_inner = ast => {
  switch(ast.type) {
    case 'call': {
      const args = ast.val.type === 'list' ? ast.val.val : [ast.val]
      console.log(args)
      if(ast.fn === 'if' && args.length === 2) {
        return `((${compile_inner(args[0])}) ? ${compile_inner(args[1])} : undefined)`
      } else if(ast.fn === 'if' && args.length === 3) {
        return `((${compile_inner(args[0])}) ? ${compile_inner(args[1])} : ${compile_inner(args[2])})`
      } else if(ast.fn === 'if') {
        // TODO: somehow do error reporting, maybe by just throwing an error inside the later eval'ed code
        return `throw Error('Syntax error')`
      } else {
        return `lib.${ast.fn}(${args.map(compile_inner).join(', ')})`
      }
    }

    case 'or':                    return _compile_binary_operator('||',  ast.val)
    case 'and':                   return _compile_binary_operator('&&',  ast.val)
    case 'inequality':            return _compile_binary_operator('!=)', ast.val)
    case 'equality':              return _compile_binary_operator('===', ast.val)
    case 'greater_than':          return _compile_binary_operator('>',   ast.val)
    case 'less_than':             return _compile_binary_operator('<',   ast.val)
    case 'greater_than_or_equal': return _compile_binary_operator('>=',  ast.val)
    case 'less_than_or_equal':    return _compile_binary_operator('<=',  ast.val)
    case 'subtraction':           return _compile_binary_operator('-',   ast.val)
    case 'addition':              return _compile_binary_operator('+',   ast.val)
    case 'multiplication':        return _compile_binary_operator('*',   ast.val)
    case 'division':              return _compile_binary_operator('/',   ast.val)
    case 'modulo':                return _compile_binary_operator('%',   ast.val)
    case 'power':                 return `lib.pow(${ast.val[0].val}, ${ast.val[1].val})`

    case 'unary_negation':        return _compile_unary_operator('!', ast.val)
    case 'unary_plus':            return _compile_unary_operator('+', ast.val)
    case 'unary_minus':           return _compile_unary_operator('-', ast.val)

    case 'range': {
      console.log(ast.val)
      const x1 = parse_col_id_format(ast.val[0].val[0])
      const x2 = parse_col_id_format(ast.val[1].val[0])
      const y1 = ast.val[0].val[1] - 1
      const y2 = ast.val[1].val[1] - 1

      const tlx = Math.min(x1, x2) // top-left
      const tly = Math.min(y1, y2)
      const brx = Math.max(x1, x2) // bottom-right
      const bry = Math.max(y1, y2)

      const results = []

      for(let j = tlx; j <= brx; j++) {
        for(let k = tly; k <= bry; k++) {
          console.log('cell:', j, k)
          results.push(`g('${k}.${j}')`) // TODO: this might need to change when `g` changes
        }
      }

      console.log(results)

      return `[${results.join(', ')}]`
    }

    case 'parenthesis':           return `(${compile_inner(ast.val)})`

    case 'boolean':               return ast.val
    case 'number':                return ast.val
    case 'string': {
      const str = parse_string(ast.val)[0]
      // what is returned is interpreted as javascript, meaning that it needs enclosing quotes
      // in order to pass as a valid string, this ensures that the right quotes are picked.
      if(ast.sub_type === 'dqstring') return `"${str}"`
      if(ast.sub_type === 'sqstring') return `'${str}'`
    } break
    case 'identifier': {
      switch(ast.val.toLowerCase()) {
        case 'pi':  return `lib.pi`
        case 'e':   return `lib.e`
        default: return `g('${ast.val}')` // TODO: this might need to change when `g` changes
      }
    }
    case 'cell':                  return `g('${ast.val[1]-1}.${parse_col_id_format(ast.val[0])}')` // TODO: this might need to change when `g` changes
    default: {
      console.log(ast)
      return `throw Error('Invalid type error')`
    }
  }
}

const parse = input => {
  const parser = new nearley.Parser(excel_grammar);
  parser.feed(input)
  return parser.finish()
}

const parse_string = str => {
  const string_parser = new nearley.Parser(string_grammar)
  string_parser.feed(str)
  return string_parser.finish()
}

const transpile = input => compile(parse(input))

window.transpile = transpile

export { parse, compile, transpile }
